<!DOCTYPE html>
<meta charset="utf-8">
<head>
	<link rel="stylesheet" href="style.css">
</head>

<body>
<script src="https://d3js.org/d3.v5.min.js"></script>

<div id = "plotting_settings">
	<div id = "bay_settings" class = "settings">
		<input type="checkbox" name="south" value="South Bay">
		<label for="south">South Bay</label><br>
		<input type="checkbox" name="suisun" value="Suisun Bay">
		<label for="suisun">Suisun Bay</label><br>
		<input type="checkbox" name="san_pablo" value="San Pablo Bay">
		<label for="san_pablo">San Pablo Bay</label><br>
	</div>
	<div id = "time_settings" class = "settings">
	</div>
	<div id = "information_settings" class = "settings">
		<input type="checkbox" name="temperature" value="Temperature">
		<label for="temperature">Temperature</label><br>
		<input type="checkbox" name="oxy_sat" value="Oxygen Saturation (%)">
		<label for="oxy_sat">Oxygen Saturation (%)</label><br>
		<input type="checkbox" name="oxy_ele" value="Oxygen Electrode Output">
		<label for="oxy_ele">Oxygen Electrode Output</label><br>
		<input type="checkbox" name="salinity" value="Salinity">
		<label for="salinity">Salinity</label><br>
	</div>
</div>

<div id = "plot_area">

</div>

<script>
d3.select("body").append("span")
    .text("Hello, world!");


const width = 1000;
const height = 500;
const margin = 40;
const padding = 5;

const adj = 100; // play with this to shrink everything at once

const svg = d3.select("div#plot_area").append("svg")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .attr("viewBox", "-"
          + adj + " -"
          + adj + " "
          + (width + adj *3) + " "
          + (height + adj*3))
    .style("padding", padding)
    .style("margin", margin)
    .classed("svg-content", true);

const san_pablo = d3.csv("/data/SanPablo_processed.csv");

const suisun = d3.csv("/data/SuisunBay_processed.csv");

const south = d3.csv("/data/SouthBay_processed.csv");

const timeConv = d3.timeParse("%Y-%m");

let plot_data = function(data) {
	/*
	------PREPARING DATA--------
	*/

	const slices = data.columns.slice(1).map(function(col_name) { // slice(1) is for ignoring the time col
		return {
			id: col_name,
			values: data.map(function(row) {
				return {
					time: timeConv(row.time),
					measurement: +row[col_name]
				}
			})
		}
	});
	console.log(slices);
	
	
	/* 
	-----------AXES-----------
	*/
	const xScale = d3.scaleTime().range([0,width]);
	const yScale = d3.scaleLinear().rangeRound([height, 0]);
	xScale.domain(d3.extent(data, function(d){ //d3.extent() returns a minimum and maximum value of an array
		const smth = timeConv(d.time);
		console.log(smth);
		console.log(smth.length);
		return timeConv(d.time)
	}));
	yScale.domain([(0), d3.max(slices, function(slice) {
			console.log(slice);
			return d3.max(slice.values, function(entry) {
				console.log(entry);
				return entry.measurement + 4; // add 4 to maximum of maximums of slices, aesthetic reasons
			
			});
			
		})
		]);
	const yAxis = d3.axisLeft()
		//.ticks((slices[0].values).length)
		.scale(yScale);
	const xAxis = d3.axisBottom()
		.ticks(d3.timeYear.every(1))
		.tickFormat(d3.timeFormat('%b %Y'))
		.scale(xScale);
	
	svg.append("g")
		.attr("class", "axis")
		.attr("transform", "translate(0," + height + ")")
		.call(xAxis);

	svg.append("g")
		.attr("class", "axis")
		.call(yAxis)
		// from here is the y Axis label
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("dy", ".75em")
		.attr("y", 6)
		.style("text-anchor", "end")
		.text("YLABEL");
	/*
	--------MAKING A LINE CHART----------
	*/
	
	
	// LINE
	/*
		Lines are essentially d3.paths() that connect a bunch of (x, y) coordinates on a 2D plane.
		To construct a line you need to tell it where to find its x and y coordinates
		and then append that to the svg.
	*/
	const line = d3.line()
		.x(function(d) {
			return xScale(d.time);
		})
		.y(function(d) {
			return yScale(d.measurement);
		});
		
	let id = 0;
	const ids = function() {
		return "line-"+id++; // generate numbered ids
	}
	const lines = svg.selectAll("lines")
		.data(slices)
		.enter()
		.append("g");

	lines.append("path")
		.attr("class", ids)
		.attr("d", function(d) { return line(d.values); });
		
	lines.append("text")
		.attr("class","series_label")
		.datum(function(d) {
			return {
				id: d.id,
				value: d.values[d.values.length - 1]}; })
		.attr("transform", function(d) {
				return "translate(" + (xScale(d.value.time) + 10)  
				+ "," + (yScale(d.value.measurement) + 5 ) + ")";})
		.attr("x", 5)
		.text(function(d) { return d.id; });

}

//san_pablo.then(prepare_data).then(prepare_axes);
//suisun.then(prepare_data).then(prepare_axes);
south.then(plot_data);//.then(prepare_axes);

/*
------------ OLDER STUFF ------------
// gets maximum & minimum of every row.
let plot_data = function(data) {

	// Get minima and maxima for domain
	let maxDict = {
		temp: 0,
		sal: 0,
		oxy_el: 0,
		oxy_sat: 0
	};
	let minDict = {
		temp: 30,
		sal: 80,
		oxy_el: 80,
		oxy_sat: 80
	}
	data.forEach(row => {
		for (const [key, value] of Object.entries(maxDict)) {
			if (row[key] > value) {
				maxDict[key] = row[key];
			}
		}
		for (const [key, value] of Object.entries(minDict)) {
			if (row[key] < value) {
				minDict[key] = row[key];
			}
		}
	});
	
	console.log(maxDict);
	console.log(minDict);

}
*/







</script>